<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>javascript</title>
</head>
<body>
	<h1>자바스크립트 연습</h1>

	<script type="text/javascript">
	<!--
		console.log("보이니");
		document.write("화면으로 보임");
		-->
	</script>
	<br>여기는 html
	<br>
	<script type="text/javascript">
		"use strict";
		var a = 5;
		let b = 10;
		const c = a + b;
		document.write(c);
	</script>
	<br>여기는 다시 html
	<br>
	<script type="text/javascript">
		document.write("이건 자바스크립트");
		document.write("변수 선언시 let과", "const 강력 추천");

		document.write("<br>kbs : ", kbs); // var은 변수를 선언하기 전에 사용 가능, 대신 undefined의 값이 할당됨 (hoisting)
		// 호이스팅이란 변수와 함수 선언이 맨 위로 이동되는 기존 자바스크립트 매커니즘
		var kbs = 9; // 전역적 global scope
		document.write("<br>kbs : ", kbs);

		{
			var v1 = 1;
			{
				var v2 = 2;
				{
					var v3 = 3;
				}
			}

		}
		//var는 전역변수로 선언되므로 var의 범위 밖에서 출력해도 정상적으로 출력됨
		document.write("<br>", v1, v2, v3);

		// document.write("<br>mbc : ", mbc); // err, let은 변수를 선언하기 전에 사용 불가 (ES6부터 hoisting 금지를 위해 나온 let)
		let mbc = 11; // 지역적 local scope
		document.write("<br>mbc : ", mbc);
		
		{
			let w1 = 1;
			{
				let w2 = 2;
				{
					let w3 = 3;
				}
			}

		}// let은 지역변수로 선언되므로 아래처럼 let의 범위 밖에서 출력하면 에러
		//document.write("<br>", w1, w2, w3);
		const sbs = 5;
		// sbs = 3; // TypeError: Assignment to constant variable.
		// 상수는 값 변경 불가
		document.write("<br>sbs : ", sbs);

		document
				.write("<br>원시 타입 : Number, String, Boolean, Undefined, Null, Simbol")
		document.write("<br>참조 타입 : Object, Array, Function");
		document.write("<br>type 확인 : ", typeof (1), ' ', typeof 1.5, ' ',
				typeof -12, ' ', typeof 'kor', ' ', typeof true, ' ',
				typeof false, ' ', typeof null, ' ', typeof undefined);
		let aa = null;
		let bb = undefined;
		let cc;
		document.write("<br>aa : ", aa, ", bb : ", bb, ", cc : ", cc);
		document.write(`<br>aa : ${aa},  bb : ${bb}, cc : ${cc}`); // back tic 문자로 감싸서 동적 변수로 만들 수 있다.
		document.write(`<br>${1 + 5 *2}`);
		
	</script>
	<br>연산자<br>
	<script type="text/javascript">
	let x = 5, y= 2;
	document.write('<br>x:', x, ', y:', y);
	document.write('<br>산술연산');
	document.write('<br>', x+y, ' ', x-y, ' ', x*y);
	document.write('<br>', x/y, ' ', x%y); // 몫, 나머지
	document.write('<br>', x**y, ' ', 4 ** (1/2), ' ', 8**(1/3));
	//제곱근, 1/2제곱근, 1/3제곱근
	
	document.write('<br>관계연산');
	document.write('<br>', x > y, ' ', x<=y, ' ', x==y, ' ', x != y);
	document.write('<br>', 5 == '5', ' ', 5 ==='5', ' ', 5!='5', ' ', 5 !== '5');
	// ==타입에 의한 비교, ===값 비교
	
	document.write('<br>논리연산');
	document.write('<br>', x > y && 7 >x); // and
	document.write('<br>', x > y || 7 >x); // or
	
	document.write('<br>삼항연산');
	document.write('<br>', (x > y)?100:200); // x>y가 true이면 100, false이면 200 출력
	
	let kor = null;
	//let kor = 100;
	let eng = 90;
	let result1 = (kor !== null && a !== undefined)?'good':'nice';
	document.write(`<br>result의 결과는 ${result1}입니다`);
	let result2 = kor??eng;
	//이 연산자는 두 개의 표현식 중 첫 번째 표현식이 null 또는 undefined일 경우, 
	//두 번째 표현식을 반환합니다. 그렇지 않으면 첫 번째 표현식을 반환합니다.
	document.write(`<br>result2의 결과는 ${result2}입니다`);
	
	document.write('<br>연산자 우선 순위 ', 10 + 20 * 2, ' ', (10+20) * 2);
	// ( ) > 산술(*, / > +, -) > 관계 > 논리 > 치환
	
	document.write('<br>문자열 더하기 연산');
	document.write('<br>', '대한' + '민국', ' ', '5' + '6', ' ', '5' + 6);
	document.write('<br>', '5' + 6, ' ', Number('5') + Number('6'), ' ', +'5' + 6);
	// '5'는 자동형변환, Number('5')는 강제형변환, +'숫자모양의 문자열' : 단항 덧셈 연산자. 숫자로 강제 형변환(Number 역할)
	document.write('<br>', '1' + 2, ' ', 1 + '2', ' ', 1+ +'2'); // + +'2'에서 +기호로 인해 문자 2가 숫자 2로 바뀜
	document.write('<br>', 6 - '2', ' ', 6*'2', ' ', 6 / '2'); // 덧셈을 제외한 나머지 사칙연산은 연산 시 숫자로 자동 형변환
	document.write('<br>', 'c' + 'a' + 't' === 'cat');
	document.write('<br>', Boolean(true), ' ', Boolean(false));
	document.write('<br>', Boolean('true'), ' ', Boolean(false));
	document.write('<br>', Boolean(123), ' ', Boolean(-123.4), Boolean('0'));
	document.write('<br>', Boolean('kor'), ' ', Boolean('홍길동'), ' ', Boolean('5'));
	document.write('<br>', Boolean(0), ' ', Boolean(false), ' ', Boolean(' '));
	document.write('<br>', Boolean(null), ' ', Boolean(undefined), ' ', Boolean(NaN)); 
	// NaN은 아래와 같이 문자를 숫자로 나눌 수 없을 때 Not a Number 에러가 떨어지면서 발생하는 것이다.
	document.write('<br>', '국어' / 2); // 문자를 숫자로 나눌 수 없으므로 NaN 에러
	
	document.write('<br>기타 연산');
	let s1, s2, s3;
	s1 = s2 = s3 = 3 + 4; // 할당(치환) 연산자 체이닝
	document.write(`<br>s1 = ${s1} s2 = ${s2} s3 = ${s3}`);
	
	document.write('<br>');
	let my = 1;
	document.write(my);
	my = my + 1;
	document.write(my);
	my += 1;
	document.write(my);
	my++;
	document.write(my);
	++my;
	document.write(my);
	
	let f1= 1, f2=2;
	document.write('<br>', 5 - (f1 = f2 + 1), ' ', '2' > 1);
	//'2' > 1 에서 문자와 숫자의 비교 연산을 하게되면 문자가 숫자로 자동형변환된다.
	</script>
</body>
</html>